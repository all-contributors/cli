# Development Documentation

## Quick reference

| Task                          | Command                      |
| ----------------------------- | ---------------------------- |
| Run tests                     | `npm test` or `npm run test` |
| Tests + coverage              | `npm run test-coverage`      |
| Lint                          | `npm run lint`               |
| Lint and fix                  | `npm run lint-fix`           |
| Build                         | `npm run build`              |
| Run from source               | `npm run dev`                |
| Link package                  | `npm link` (see Build)       |
| Run knip (for unused imports) | `npm run knip`               |

## Testing and Code Coverage

### Run our test suite

The project uses Vitest to write and run tests. To run the test suite use the
command:

```bash
npm test
```

That runs all tests without a coverage report. If you want coverage (handy for
seeing what's covered and what's now), use `npm run test-coverage`—see Coverage
reports below.

If you like running tests from VS Code, install the Vitest extension or use the
built-in test runner so your tests are discovered and you can debug in the IDE.

When you run the test suite it will default to running all tests and we continue
to run in "watch" mode. This means that if you make changes to the code, the
tests will automatically re-run.

To exit the watch mode, you can press `Ctrl+C` or `Command+C` depending on your
operating system. Or hit `q` which prompt vitest to exit.

### Test Configuration

Test configuration is in `vitest.config.ts`.

### Coverage Thresholds

The project enforces minimum code coverage thresholds through the Vitest
configuration file:

| Coverage Type | Percentage |
| ------------- | ---------- |
| Branches      | 50%        |
| Functions     | 40%        |
| Lines         | 50%        |
| Statements    | 50%        |

Tests will fail if coverage drops below these thresholds.

TODO: We likely want much higher coverage than this given the use of the project
but for now we are slowly refactoring and improving coverage as we go.

### Coverage Reports

Run `npm run test-coverage` to generate coverage reports in the `coverage/`
directory:

- **`coverage/lcov-report/index.html`** — Interactive HTML report (open in a
  browser to explore)
- **`coverage/lcov.info`** — LCOV format (used by Codecov)

The HTML report gives you a visual breakdown of which files are covered by
tests.

### Codecov Integration

The project uses Codecov to track code coverage over time and on pull requests.

#### CI integration

- The GitHub Actions workflow (`.github/workflows/test-deploy.yml`) uploads
  coverage to Codecov after running tests
- Coverage reports appear as comments on pull requests (if enabled)
- The workflow uses `codecov/codecov-action@vxxx` (whatever version is most
  recent) to upload the `lcov.info` file

#### Configuration

Codecov is configured in `.codecov.yml`:

- Patch coverage is tracked (checks coverage of changed code in PRs)
- Project-level status checks are disabled
- PR comments are disabled
- Codecov now requires a token for all uploads so we have one generated in the
  repo as a secret `secrets.CODECOV_TOKEN`. This token was generated by
  `@lwasser` but it can be easily regenerated if a maintianer needs to do that.

#### Local usage

You don't need a Codecov account to view coverage locally. Just run
`npm run test-coverage` and open the HTML report. The Codecov integration is
mainly for tracking coverage over time and for PR reviews in CI.

## Linting

The project uses ESLint 9 with a native configuration (we migrated from
kcd-scripts). The setup supports both CommonJS source files and ES module test
files.

### How to run the linter

To check for linting errors:

```bash
npm run lint
```

To fix many issues automatically (recommended before committing):

```bash
npm run lint-fix
```

The fix command handles a lot of common issues, for example:

- Vitest method aliases (e.g. `toThrowError()` → `toThrow()`)
- Unused eslint-disable directives
- Many formatting issues

Some things still need manual fixes (e.g. unused variables, tests without
assertions), but lint-fix will get you most of the way there.

### Pre-commit hooks

We use Husky so that staged files are linted and fixed before each commit. That
way the codebase stays consistent without you having to remember to run lint
every time.

1. When you run `git commit`, Husky runs `lint-staged`.
2. `lint-staged` runs `eslint --fix` and Prettier on staged JS/TS files.
3. If everything passes, the commit goes through; if not, the commit is blocked
   so you can fix the issues.

If the hook fails, run `npm run lint-fix` (see above) and address any remaining
errors. If you're in a pinch, you can skip the hook once with
`git commit --no-verify`—but if you do that, please mention it in your PR so a
maintainer can help you get things passing.

Husky and `lint-staged` are configured in `package.json`; the ESLint config
lives in `eslint.config.mjs`.

### Dependencies

These are the main packages we use for linting:

- **eslint** — ESLint core
- **@eslint/js** — Recommended rules
- **eslint-plugin-import** — Import/export rules and module resolution
- **@vitest/eslint-plugin** — Vitest-specific rules for test files
- **globals** — Global variables for Node and Vitest environments

### Configuration file

The ESLint config is in `eslint.config.mjs` at the project root. It uses ESLint
9's flat config format and includes:

- Base rules from `eslint:recommended`
- Import plugin rules
- Vitest plugin rules (for test files only)
- Custom overrides for project-specific needs
- Support for both CommonJS and ES module syntax

## Build and local testing

The build has been migrated from `kcd-scripts build` to native Babel. After a
build, the CLI runs from the `dist/` directory.

### How to build

From the repo root:

```bash
npm run build
```

That compiles `src/` into `dist/` using Babel (see `babel.config.js`). The entry
point is `dist/cli.js`; you can also run it with `npm start`.

### Running from source (no build)

When you're developing, you often don't need to build. You can run the CLI from
source instead:

```bash
npm run dev
```

That runs `./src/cli.js` directly. Use it when you're iterating; use the built
package when you want to test the same code path that users get after they
install from npm.

### Linking the package locally

If you want to install the cli as if you'd installed it from npm you can do so
by linking the package locally.

1. In the CLI repo root, build and link the project:
   ```bash
   npm run build
   npm link
   ```
2. In another directory (any repo that has a `.all-contributorsrc`, or wherever
   you want to run the binary), the global `all-contributors` command will now
   use your built package. run:

   ```bash
   all-contributors add <username> code
   all-contributors generate
   ```

3. When you're done, you can unlink with `npm unlink -g all-contributors-cli` in
   the CLI repo, and reinstall the real package elsewhere if you need to.

### Testing the linked package

Once you've run `npm link`, switch to another directory and run
`all-contributors` commands as you normally would. Confirm that behavior matches
what you expect.

Remember: after you change code in the CLI repo, run `npm run build` again
before testing from the other directory. The link points at the built `dist/`
output, so your latest changes won't show up until you rebuild.

This workflow is a great way to double-check the built artifact and the exact
code path users get when they install the package.

### Build dependencies (migration notes)

We removed most of the build dependencies that kcd-scripts used; they're
redundant with current Node.

Removed: `@babel/plugin-transform-class-properties`, `babel-plugin-macros`,
`semver`, `@babel/runtime`.

Kept: `@babel/cli`, `@babel/core` (and any others you see in `package.json`).
